package com.anthem.pdt.common.batch.reader;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.item.NonTransientResourceException;
import org.springframework.batch.item.ParseException;
import org.springframework.batch.item.UnexpectedInputException;
import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.Order;
import org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.RowMapper;

import com.anthem.pdt.common.batch.dto.QualificationEntity;
import com.anthem.pdt.common.constants.Constants;

@Configuration
public class PdtQualificationEntityReader{
	
	private static Logger logger = LoggerFactory.getLogger(PdtQualificationEntityReader.class);	
	
	@Qualifier("oracleDataSource")
	@Autowired
	private DataSource dataSource;	
		
	@Value("${submission.status}")
	private String submissionStatus;
	
	@Value("${current.value}")
	private int currentvalue;
	
	@Value("${mod.value}")
	private int modvalue ;
	
	@Autowired
	private RowMapper<QualificationEntity> mapper;
	
		@Bean
		public JdbcPagingItemReader<QualificationEntity> qfreader()
				throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException {
			JdbcPagingItemReader<QualificationEntity> read = new JdbcPagingItemReader<>();
			read.setDataSource(this.dataSource);
			read.setFetchSize(1000);
			read.setRowMapper(mapper);
			
			Map<String, Order> sortKeys = new HashMap<>();
			sortKeys.put("id", Order.ASCENDING);
			
			final SqlPagingQueryProviderFactoryBean sqlPagingQueryProviderFactoryBean = new SqlPagingQueryProviderFactoryBean();
			sqlPagingQueryProviderFactoryBean.setDataSource(dataSource);
			long startTime = System.currentTimeMillis();
			sqlPagingQueryProviderFactoryBean.setSelectClause(Constants.QUALIFICATION_SELECT_CLAUSE);
			sqlPagingQueryProviderFactoryBean.setFromClause(Constants.QUALIFICATION_FROM_CLAUSE.replace("$Sbmn_Status$",submissionStatus).replace("$mod_value$", String.valueOf(modvalue)).replace("$currentvalue$", String.valueOf(currentvalue)));
//			sqlPagingQueryProviderFactoryBean.setWhereClause(Constants.QUALIFICATION_WHERE_CLAUSE);
			
			sqlPagingQueryProviderFactoryBean.setSortKey("QUAL_RESOURCE_ID");
			try {
				read.setQueryProvider(sqlPagingQueryProviderFactoryBean.getObject());
			} catch (Exception e) {
				e.printStackTrace();
			}
			logger.info("Time taken for Query Execution is " + String.valueOf(System.currentTimeMillis() - startTime));
			read.setPageSize(1000);
			read.setSaveState(false);
			return read;
		}
		

}
package com.anthem.pdt.common.batch.reader;

import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.Order;
import org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean;
import org.springframework.jdbc.core.RowMapper;

import com.anthem.pdt.common.batch.dto.QualificationEntity;
import com.anthem.pdt.common.constants.Constants;

@RunWith(MockitoJUnitRunner.class)
public class PdtQualificationEntityReaderTest {

    private static final Logger logger = LoggerFactory.getLogger(PdtQualificationEntityReaderTest.class);

    @Mock
    private DataSource dataSource;

    @Mock
    private RowMapper<QualificationEntity> mapper;

    @Mock
    private SqlPagingQueryProviderFactoryBean sqlPagingQueryProviderFactoryBean;

    @InjectMocks
    private PdtQualificationEntityReader pdtQualificationEntityReader;

    private String submissionStatus = "SUBMITTED";
    private int currentvalue = 1;
    private int modvalue = 5;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        // Initialize mock behavior for the constants and variables
        pdtQualificationEntityReader.submissionStatus = submissionStatus;
        pdtQualificationEntityReader.currentvalue = currentvalue;
        pdtQualificationEntityReader.modvalue = modvalue;
    }

    @Test
    public void testQfreader() throws Exception {
        // Mock the SQL paging provider behavior
        SqlPagingQueryProviderFactoryBean sqlPagingQueryProviderFactoryBean = mock(SqlPagingQueryProviderFactoryBean.class);
        when(sqlPagingQueryProviderFactoryBean.getObject()).thenReturn(mock(SqlPagingQueryProviderFactoryBean.class));

        // Call the method under test
        JdbcPagingItemReader<QualificationEntity> reader = pdtQualificationEntityReader.qfreader();

        // Verify the interactions with dataSource, rowMapper, etc.
        verify(dataSource, times(1)).getConnection();
        verify(sqlPagingQueryProviderFactoryBean, times(1)).setDataSource(dataSource);
        verify(sqlPagingQueryProviderFactoryBean, times(1)).setSelectClause(Constants.QUALIFICATION_SELECT_CLAUSE);
        verify(sqlPagingQueryProviderFactoryBean, times(1)).setFromClause(
                Constants.QUALIFICATION_FROM_CLAUSE.replace("$Sbmn_Status$", submissionStatus)
                        .replace("$mod_value$", String.valueOf(modvalue))
                        .replace("$currentvalue$", String.valueOf(currentvalue))
        );
        verify(sqlPagingQueryProviderFactoryBean, times(1)).setSortKey("QUAL_RESOURCE_ID");

        // Verify if the reader is properly configured
        assert(reader != null);
        assert(reader.getFetchSize() == 1000);
        assert(reader.getPageSize() == 1000);
        assert(!reader.isSaveState());
    }
}
public class PdtQualificationEntityProcessor {

	@Autowired
	private CustomQualificationProcessor customQualificationProcessor;

	@Bean
    public AsyncItemProcessor asyncQualificationEntityItemProcessor() throws Exception{
       AsyncItemProcessor<QualificationEntity, Organization> asyncItemProcessor = new AsyncItemProcessor<>();
       asyncItemProcessor.setDelegate(processorqe());
       asyncItemProcessor.setTaskExecutor(new SimpleAsyncTaskExecutor());
       asyncItemProcessor.afterPropertiesSet();
       return asyncItemProcessor;
    }
	 @Bean
		public ItemProcessor<QualificationEntity, Organization> processorqe() {

			return customQualificationProcessor;
		}

		
package com.anthem.pdt.common.batch.reader;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import javax.sql.DataSource;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.PagingQueryProvider;
import org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean;
import org.springframework.jdbc.core.RowMapper;

import com.anthem.pdt.common.batch.dto.QualificationEntity;
import com.anthem.pdt.common.constants.Constants;

@RunWith(MockitoJUnitRunner.class)
public class PdtQualificationEntityReaderTest {

    @Mock
    private DataSource dataSource;

    @Mock
    private RowMapper<QualificationEntity> mapper;

    @Mock
    private SqlPagingQueryProviderFactoryBean sqlPagingQueryProviderFactoryBean;

    @Mock
    private PagingQueryProvider pagingQueryProvider; // Mock the PagingQueryProvider

    @InjectMocks
    private PdtQualificationEntityReader pdtQualificationEntityReader;

    private String submissionStatus = "SUBMITTED";
    private int currentvalue = 1;
    private int modvalue = 5;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Mock the PagingQueryProvider
        when(sqlPagingQueryProviderFactoryBean.getObject()).thenReturn(pagingQueryProvider);

        // Set necessary values in PdtQualificationEntityReader
        pdtQualificationEntityReader.submissionStatus = submissionStatus;
        pdtQualificationEntityReader.currentvalue = currentvalue;
        pdtQualificationEntityReader.modvalue = modvalue;
    }

    @Test
    public void testQfreader() throws Exception {
        // Call the method under test
        JdbcPagingItemReader<QualificationEntity> reader = pdtQualificationEntityReader.qfreader();

        // Assert the reader is not null
        assertNotNull(reader);

        // Verify that fetch size is set to 1000
        assertEquals(1000, reader.getFetchSize()); // Check fetch size

        // Verify other configurations of the reader
        assertEquals(1000, reader.getPageSize());  // Page size should also be 1000
        assertFalse(reader.isSaveState());  // Save state should be disabled

        // Ensure the query provider is set
        assertNotNull(reader.getQueryProvider());
    }
}
